{"componentChunkName":"component---src-templates-blog-post-js","path":"/2020-12-21/","result":{"data":{"site":{"siteMetadata":{"title":"AnyFer üê¶"}},"markdownRemark":{"id":"da1d73e5-8e9e-519e-82e9-920ae83fd8b3","excerpt":"Time traveling in Swift is possible. This is a series that describe how Unidirectional architectures can be applied in Swift and how we can do very impressive‚Ä¶","html":"<p>Time traveling in Swift is possible. This is a series that describe how Unidirectional architectures can be applied in Swift and how we can do very impressive things by enforcing them.</p>\n<p>This is the first article in the series, but before deep diving into Swift specifics. I‚Äôd like to give you an introduction to the general concepts that make all of this possible.</p>\n<h1>What is time traveling?</h1>\n<p>Of course this is not my idea. Time Traveling has been discussed in the Javascript world <a href=\"https://www.youtube.com/watch?v=uvAXVMwHJXU&#x26;ab_channel=ReactEurope\">several times</a>. However, there are not so many examples of it in Swift. </p>\n<p>When we talk about time traveling in the context of a Frontend application, <a href=\"https://youtu.be/8QNGrxOKVW8\">this is what we have in mind</a>.</p>\n<p>We can record user sessions, and then reproduce the actions, go back, go forward, and ‚Äútravel‚Äù in time, because all the actions are reproducible.</p>\n<h1>The main components</h1>\n<p>A word in the previous description is important: <code class=\"language-text\">Actions</code>. An <code class=\"language-text\">Action</code> is an object that describes something that happened in the system. </p>\n<p>Did the user change the text in a textfield? That is an <code class=\"language-text\">Action</code>.</p>\n<p>Did the user tap the button to create a To Do? That is an <code class=\"language-text\">Action</code>.</p>\n<p>Did the user complete a To Do? That is also an <code class=\"language-text\">Action</code>.</p>\n<p>Given that, if we want to describe something that happened in the system, anything, we need to create an <code class=\"language-text\">Action</code> that describes the event.</p>\n<p><img src=\"https://dev-to-uploads.s3.amazonaws.com/i/cxhqio1124haq3up27br.png\" alt=\"arch-001\"> </p>\n<p>‚Äî</p>\n<p>In order to time travel, we need to be able to get a certain <code class=\"language-text\">State</code> for the system by applying the <code class=\"language-text\">Action</code> objects, sequentially. Nothing else can possibly affect or modify the <code class=\"language-text\">State</code>. If anything else was able to mutate the <code class=\"language-text\">State</code> other than an action, then we couldn‚Äôt reproduce old states accordingly.</p>\n<p><img src=\"https://dev-to-uploads.s3.amazonaws.com/i/vmbo9vw98n99vcqejocr.png\" alt=\"unidirectional-005\"> </p>\n<p>In the diagram above, I illustrate how a sequence of actions resulted in a state with an empty <code class=\"language-text\">text</code> attribute and an array with a single <code class=\"language-text\">todo</code> object that is completed. If we removed the <code class=\"language-text\">toggleTodo</code> action, we could apply all the other actions and get a state which is in turn the previous state. <strong>It is an undo event.</strong></p>\n<p><img src=\"https://dev-to-uploads.s3.amazonaws.com/i/qxtvf84x8xv5erzcd0fk.png\" alt=\"unidirectional-006\"> </p>\n<p>We can also store the deleted actions in a separate stack, so we can bring those back to the main actions stack and calculate the state again. <strong>It is a redo event.</strong></p>\n<p><img src=\"https://dev-to-uploads.s3.amazonaws.com/i/fuaxnw8gxoxqcxfofbh4.png\" alt=\"unidirectional-004\"> </p>\n<p>So, we apply a set of <code class=\"language-text\">Action</code> objects, and we get a resulting application <code class=\"language-text\">State</code>. So far, so good. But, we can think of actions as an <code class=\"language-text\">enum</code> with a number of cases with associated values, and the <code class=\"language-text\">State</code> of a struct or a class with all the values inside, and that‚Äôs ok. However, something is missing: how is state mutated? Where is that mutation described?</p>\n<h1>The missing piece: The reducer</h1>\n<p>A <code class=\"language-text\">reducer</code> is a pure function. That means that its output is only calculated based on its input. It is a function in the traditional mathematical sense of the concept. Each element in its domain has only one element in its image.  </p>\n<p><img src=\"https://dev-to-uploads.s3.amazonaws.com/i/2191mzcy0dfeaf1kzint.png\" alt=\"Untitled-001\"> </p>\n<p>Image from <a href=\"https://www.google.com/url?sa=i&#x26;url=https%3A%2F%2Fwww.mathsisfun.com%2Fsets%2Ffunction.html&#x26;psig=AOvVaw29Q5XLkHBd9oCYOmfZcTA_&#x26;ust=1608299865313000&#x26;source=images&#x26;cd=vfe&#x26;ved=0CA0QjhxqFwoTCPjAwYOW1e0CFQAAAAAdAAAAABAI\">Math is fun</a></p>\n<p>The <code class=\"language-text\">reducer</code> is the only function which is allowed to perform mutations in the <code class=\"language-text\">State</code>. Ok, it doesn‚Äôt mutate the <code class=\"language-text\">State</code>. It actually produces new states based on the previous <code class=\"language-text\">State</code> and an <code class=\"language-text\">Action</code>. It does so because it should only depend on its input. If it mutated the current state, it would also depend in a variable from the outside.</p>\n<p><img src=\"https://dev-to-uploads.s3.amazonaws.com/i/scp4o657rif164cgz89z.png\" alt=\"unidirectional-008\"></p>\n<p>For each <code class=\"language-text\">Action</code> we get in the system, we send that action to the <code class=\"language-text\">reducer</code> along with the current <code class=\"language-text\">State</code>. The <code class=\"language-text\">reducer</code> returns the new <code class=\"language-text\">State</code>, so we store that value and we are prepared for the next <code class=\"language-text\">Action</code> that we will eventually get. </p>\n<p><img src=\"https://dev-to-uploads.s3.amazonaws.com/i/kx34772t9lzaan5iaail.png\" alt=\"unidirectional-007\"></p>\n<p>Due to the <strong>functional purity</strong> of the <code class=\"language-text\">reducer</code>, and given that all the events that could possibly mutate the <code class=\"language-text\">State</code> are expressed through an <code class=\"language-text\">Action</code>, each step is reproducible. We can travel in time by storing all the actions and calculate previous and next <code class=\"language-text\">State</code> values by applying all the <code class=\"language-text\">Action</code> values sequentially using the <code class=\"language-text\">reducer</code> function.</p>\n<h1>f(State) = UI</h1>\n<p>For all of this to work, we need to enforce <strong>functional purity</strong> in another transformation: <strong>the view should be a pure function of the application state</strong>.</p>\n<p><img src=\"https://dev-to-uploads.s3.amazonaws.com/i/xw12qh1wv5ix98mi6v4e.png\" alt=\"unidirectional-009\"></p>\n<p>Changes in the application states will produce modifications in the View to happen. This may sound as a lot of work, but keep in mind to things:</p>\n<ol>\n<li>The power of programming depends more on the things you can‚Äôt do than on the things you are able to do. Applying restrictions to the things you can do is a way of getting properties in your system that allow you to do this kind of things.</li>\n<li>SwiftUI already does this for you for free. Views in SwiftUI are rendered depending only on the state you have on them and on your <code class=\"language-text\">ObservableObjects</code>. This is taking that approach one step forward, and centralizing all your state in a single, big State object that can be mutated only by a function called <code class=\"language-text\">reducer</code>.</li>\n</ol>\n<h1>The store</h1>\n<p>There is another component that hasn‚Äôt been discussed so far. The <code class=\"language-text\">Store</code> is an object, that can be implemented in SwiftUI as a <code class=\"language-text\">ObservableObject</code>, that holds our <code class=\"language-text\">State</code>, our <code class=\"language-text\">reducer</code>, and exposes a function called <code class=\"language-text\">dispatch(action:)</code>, which takes an <code class=\"language-text\">Action</code> and replaces the current <code class=\"language-text\">State</code> for the result of the <code class=\"language-text\">reducer</code> function.</p>\n<p><img src=\"https://dev-to-uploads.s3.amazonaws.com/i/jqxk0pgke8jewg731lak.png\" alt=\"unidirectional-11_(1)\"></p>\n<h1>To sum up</h1>\n<p>As said, <strong>The power of programming depends more on the things you can‚Äôt do than on the things you are able to do.</strong> If you enforce functional purity in your application, and express all mutations through actions, the state then becomes reproducible, you can go back and forward as you want, you can record user sessions, and many many many other things we havent covered in this article. </p>\n<p>In the next article, we will translate all of this in actual Swift/SwiftUI code, so you will get a more practical understanding on how all of this fits in a real app.</p>\n<p>If you want to learn an iOS architecture that applies all of this and is production ready, I would HIGHLY recommend <a href=\"https://github.com/pointfreeco/swift-composable-architecture\">The Composable Architecture</a>.</p>","frontmatter":{"title":"Unidirectional Architectures and time traveling in Swift: I","date":"December 21, 2020","description":null}},"previous":{"fields":{"slug":"/2020-12-13/"},"frontmatter":{"title":"On testing private methods"}},"next":{"fields":{"slug":"/2020-12-27/"},"frontmatter":{"title":"Unidirectional Architectures and time traveling in Swift: II"}}},"pageContext":{"id":"da1d73e5-8e9e-519e-82e9-920ae83fd8b3","previousPostId":"be14eec7-3f9e-571d-b55c-bf9482c0f794","nextPostId":"26826c7d-af07-5b84-be2c-d642afe60cdd"}},"staticQueryHashes":["2841359383","916993862"]}